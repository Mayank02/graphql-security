"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _selectn = _interopRequireDefault(require("selectn"));

var _values = require("graphql/execution/values");

var _graphql = require("graphql");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function costAnalysisMessage(max, actual) {
  return "The query exceeds the maximum cost of ".concat(max, ". ") + "Actual cost is ".concat(actual);
}

var CostAnalysis =
/*#__PURE__*/
function () {
  function CostAnalysis(context, options) {
    _classCallCheck(this, CostAnalysis);

    (0, _assert.default)(typeof options.maximumCost === 'number' && options.maximumCost > 0, 'Maximum query cost must be a positive number');

    if (options.complexityRange) {
      (0, _assert.default)(options.complexityRange.min && options.complexityRange.max && options.complexityRange.min < options.complexityRange.max, 'Invalid minimum and maximum complexity');
    }

    this.context = context;
    this.cost = 0;
    this.options = options;
    this.operationMultipliers = [];
    this.defaultCost = this.options.defaultCost || 0;
    this.defaultComplexity = this.options.complexityRange && this.options.complexityRange.min || 1;
    this.OperationDefinition = {
      enter: this.onOperationDefinitionEnter,
      leave: this.onOperationDefinitionLeave
    };
  }

  _createClass(CostAnalysis, [{
    key: "onOperationDefinitionEnter",
    value: function onOperationDefinitionEnter(operation) {
      switch (operation.operation) {
        case 'query':
          this.cost += this.computeNodeCost(operation, this.context.getSchema().getQueryType());
          break;

        case 'mutation':
          this.cost += this.computeNodeCost(operation, this.context.getSchema().getMutationType());
          break;

        case 'subscription':
          this.cost += this.computeNodeCost(operation, this.context.getSchema().getSubscriptionType());
          break;

        default:
          throw new Error("Query Cost could not be calculated for operation of type ".concat(operation.operation));
      }
    }
  }, {
    key: "onOperationDefinitionLeave",
    value: function onOperationDefinitionLeave() {
      if (this.options.onComplete) {
        this.options.onComplete(this.cost);
      }

      if (this.cost > this.options.maximumCost) {
        return this.context.reportError(this.createError());
      }
    }
  }, {
    key: "computeCost",
    value: function computeCost() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          multiplier = _ref.multiplier,
          _ref$useMultipliers = _ref.useMultipliers,
          useMultipliers = _ref$useMultipliers === void 0 ? true : _ref$useMultipliers,
          _ref$complexity = _ref.complexity,
          complexity = _ref$complexity === void 0 ? this.defaultComplexity : _ref$complexity,
          _ref$multipliers = _ref.multipliers,
          multipliers = _ref$multipliers === void 0 ? [] : _ref$multipliers;

      if (_typeof(arguments[0]) !== 'object') {
        return this.defaultCost;
      } // multiplier is deprecated


      if (multiplier) {
        multipliers = multipliers.length ? multipliers : [multiplier];
        process.env.NODE_ENV !== 'production' && console.warn("The multiplier property is DEPRECATED and will be removed in the next release. \n" + "Please use the multipliers field instead.");
      }

      if (this.options.complexityRange && (complexity > this.options.complexityRange.max || complexity < this.options.complexityRange.min)) {
        this.context.reportError(new _graphql.GraphQLError("The complexity argument must be between " + "".concat(this.options.complexityRange.min, " and ").concat(this.options.complexityRange.max)));
        return this.defaultCost;
      }

      if (useMultipliers) {
        if (multipliers.length) {
          var _multiplier = multipliers.reduce(function (total, current) {
            return total + current;
          }, 0);

          this.operationMultipliers = _toConsumableArray(this.operationMultipliers).concat([_multiplier]);
        }

        return this.operationMultipliers.reduce(function (acc, multiplier) {
          return acc * multiplier;
        }, complexity);
      }

      return complexity;
    }
  }, {
    key: "getArgsFromCostMap",
    value: function getArgsFromCostMap(node, parentType, fieldArgs) {
      var costObject = this.options.costMap && this.options.costMap[parentType] && this.options.costMap[parentType][node.name.value];

      if (!costObject) {
        return;
      }

      var useMultipliers = costObject.useMultipliers,
          multiplier = costObject.multiplier,
          complexity = costObject.complexity,
          multipliers = costObject.multipliers;
      multiplier = multiplier && (0, _selectn.default)(multiplier, fieldArgs);
      multipliers = this.getMultipliersFromString(multipliers, fieldArgs);
      return {
        useMultipliers: useMultipliers,
        multiplier: multiplier,
        complexity: complexity,
        multipliers: multipliers
      };
    }
  }, {
    key: "getMultipliersFromListNode",
    value: function getMultipliersFromListNode(listNode, fieldArgs) {
      var multipliers = [];
      listNode.forEach(function (node) {
        if (node.kind === _graphql.Kind.STRING) {
          multipliers.push(node.value);
        }
      });
      return this.getMultipliersFromString(multipliers, fieldArgs);
    }
  }, {
    key: "getMultipliersFromString",
    value: function getMultipliersFromString() {
      var multipliers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var fieldArgs = arguments.length > 1 ? arguments[1] : undefined;
      // get arguments values, convert to integer and delete 0 values from list
      return multipliers.map(function (multiplier) {
        var value = (0, _selectn.default)(multiplier, fieldArgs); // if the argument is an array, the multiplier will be the length of it

        if (Array.isArray(value)) {
          return value.length;
        }

        return Number(value) || 0;
      }).filter(function (multiplier) {
        return multiplier !== 0;
      });
    }
  }, {
    key: "getArgsFromDirectives",
    value: function getArgsFromDirectives(directives, fieldArgs) {
      var costDirective = directives.find(function (directive) {
        return directive.name.value === 'cost';
      });

      if (costDirective && costDirective.arguments) {
        // get cost arguments
        var complexityArg = costDirective.arguments.find(function (arg) {
          return arg.name.value === 'complexity';
        });
        var useMultipliersArg = costDirective.arguments && costDirective.arguments.find(function (arg) {
          return arg.name.value === 'useMultipliers';
        });
        var multiplierArg = costDirective.arguments && costDirective.arguments.find(function (arg) {
          return arg.name.value === 'multiplier';
        });
        var multipliersArg = costDirective.arguments && costDirective.arguments.find(function (arg) {
          return arg.name.value === 'multipliers';
        }); // get arguments's values

        var useMultipliers = useMultipliersArg && useMultipliersArg.value && useMultipliersArg.value.kind === _graphql.Kind.BOOLEAN ? useMultipliersArg.value.value : true;
        var multipliers = multipliersArg && multipliersArg.value && multipliersArg.value.kind === _graphql.Kind.LIST ? this.getMultipliersFromListNode(multipliersArg.value.values, fieldArgs) : [];
        var multiplier = multiplierArg && multiplierArg.value.value ? Number((0, _selectn.default)(multiplierArg.value.value, fieldArgs)) : undefined;
        var complexity = complexityArg && complexityArg.value && complexityArg.value.kind === _graphql.Kind.INT ? Number(complexityArg.value.value) : this.defaultComplexity;
        return {
          complexity: complexity,
          multiplier: multiplier,
          multipliers: multipliers,
          useMultipliers: useMultipliers
        };
      }
    }
  }, {
    key: "computeNodeCost",
    value: function computeNodeCost(node, typeDef) {
      var parentMultipliers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      if (!node.selectionSet) {
        return 0;
      }

      var fields = {};

      if (typeDef instanceof _graphql.GraphQLObjectType || typeDef instanceof _graphql.GraphQLInterfaceType) {
        fields = typeDef.getFields();
      }

      var selections = node.selectionSet.selections;
      var total = 0;
      var fragmentCosts = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = selections[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var childNode = _step.value;
          // reset the operation multipliers with parentMultipliers for each childNode
          // it resolves issue #14: https://github.com/pa-bru/graphql-cost-analysis/issues/14
          this.operationMultipliers = _toConsumableArray(parentMultipliers);
          var nodeCost = this.defaultCost;

          switch (childNode.kind) {
            case _graphql.Kind.FIELD:
              {
                var field = fields[childNode.name.value]; // Invalid field, should be caught by other validation rules

                if (!field) {
                  break;
                }

                var fieldType = (0, _graphql.getNamedType)(field.type); // get field's arguments

                var fieldArgs = {};

                try {
                  fieldArgs = (0, _values.getArgumentValues)(field, childNode, this.options.variables || {});
                } catch (e) {
                  this.context.reportError(e);
                } // it the costMap option is set, compute the cost with the costMap provided
                // by the user.


                if (this.options.costMap && _typeof(this.options.costMap) === 'object') {
                  var costMapArgs = typeDef && typeDef.name ? this.getArgsFromCostMap(childNode, typeDef.name, fieldArgs) : undefined;
                  nodeCost = this.computeCost(costMapArgs);
                } else {
                  // Compute cost of current field with its cost directive
                  var costIsComputed = false;

                  if (field.astNode && field.astNode.directives) {
                    var directiveArgs = this.getArgsFromDirectives(field.astNode.directives, fieldArgs);
                    nodeCost = this.computeCost(directiveArgs);

                    if (directiveArgs) {
                      costIsComputed = true;
                    }
                  } // if the cost directive is defined on the Type
                  // and the nodeCost has not already been computed


                  if (fieldType && fieldType.astNode && fieldType.astNode.directives && fieldType instanceof _graphql.GraphQLObjectType && costIsComputed === false) {
                    var _directiveArgs = this.getArgsFromDirectives(fieldType.astNode.directives, fieldArgs);

                    nodeCost = this.computeCost(_directiveArgs);
                  }
                }

                var childCost = 0;
                childCost = this.computeNodeCost(childNode, fieldType, this.operationMultipliers);
                nodeCost += childCost;
                break;
              }

            case _graphql.Kind.FRAGMENT_SPREAD:
              {
                var fragment = this.context.getFragment(childNode.name.value);
                var fragmentType = fragment && this.context.getSchema().getType(fragment.typeCondition.name.value);
                var fragmentNodeCost = fragment ? this.computeNodeCost(fragment, fragmentType, this.operationMultipliers) : this.defaultCost;
                fragmentCosts.push(fragmentNodeCost);
                nodeCost = 0;
                break;
              }

            case _graphql.Kind.INLINE_FRAGMENT:
              {
                var inlineFragmentType = typeDef;

                if (childNode.typeCondition && childNode.typeCondition.name) {
                  inlineFragmentType = this.context.getSchema() // $FlowFixMe: don't know why Flow thinks it could be undefined
                  .getType(childNode.typeCondition.name.value);
                }

                var _fragmentNodeCost = childNode ? this.computeNodeCost(childNode, inlineFragmentType, this.operationMultipliers) : this.defaultCost;

                fragmentCosts.push(_fragmentNodeCost);
                nodeCost = 0;
                break;
              }

            default:
              {
                nodeCost = this.computeNodeCost(childNode, typeDef);
                break;
              }
          }

          total = Math.max(nodeCost, 0) + total;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (!fragmentCosts.length) {
        return total;
      }

      return total + Math.max.apply(Math, fragmentCosts);
    }
  }, {
    key: "createError",
    value: function createError() {
      if (typeof this.options.createError === 'function') {
        return this.options.createError(this.options.maximumCost, this.cost);
      }

      return new _graphql.GraphQLError(costAnalysisMessage(this.options.maximumCost, this.cost));
    }
  }]);

  return CostAnalysis;
}();

exports.default = CostAnalysis;